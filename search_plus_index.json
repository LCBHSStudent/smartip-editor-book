{"./":{"url":"./","title":"SmartIP Editor 开发文档","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 项目目录结构 软件架构 重要类说明 其他常用操作 SmartIP Editor 开发文档 本文档包含以下几个部分 项目目录结构 包含对项目文件夹树各文件夹结点功能与作用的说明 软件架构 包含软件设计结构、对象关系的说明 重要类说明 包含对项目中重要程度较高、引用较为频繁的类对象结构单独分析解释 其他常用操作 包含在开发外可能用到的其他操作如：项目打包、工作环境清理、重新构建依赖等的说明 Copyright © Aron.Li 2019 all right reserved，powered by Gitbook该文件修订时间： 2021-06-14 14:05:19 "},"ProjectStructure.html":{"url":"ProjectStructure.html","title":"项目目录结构","keywords":"","body":"项目目录结构 ├─cmake │ └─modules 查找依赖库所用的findPackage cmake文件，勿修改 │ ├─data 包含程序所使用的资源文件(图标)，过滤器(filter: mlt_service)的参数配置文件.xml │ 以及其他的一些配置文件(如KdenliveSettings类的生成文件kdenliveSettings.kcfg) │ [注——mlt_service中效果的类别主要有：1. effect-效果 2. transition-转场 3. mix-混合 generator-生成器] │ ├─fuzzer 模糊测试器，通过连接到kdenlivelib从而能够使用特定的操作步骤(如mock)模拟项目资源的变化，生成的可执行文件为 fuzz 和 fuzz_reproduce │ fakeit_standalone.hpp 此独立头文件提供基于c++ template的mock手段，用于生成虚拟对象 │ fuzzing.cpp |---| │ fuzzing.hpp | 定义和实现了模糊测试内容 │ main_fuzzer.cpp 依据内容生成测试执行文件fuzz │ main_reproducer.cpp 依据内容生成测试执行文件fuzz_reproduce │ ├─gitbook gitbook文档目录 │ ├─packaging (打包/安装)(应用程序/依赖)的相关脚本文件 │ ├─plugins 演示了一个通过继承ClipGenerator类并设置参数调用kdenlive renderer，创建mlt-xml文档后生成剪辑素材的软件插件 │ ├─renderer 简单封装了mlt-melt的视频渲染器 │ kdenlive_render [-erase] [-kuiserver] [-locale:LOCALE] [in=pos] [out=pos] [render] [profile] [rendermodule] [player] [src] [dest] │ [[arg1] [arg2] ...] \" -erase: 渲染结束时删除传入的src文件\" \" -kuiserver: 使用 KDE 任务追踪器UI组件显示任务状态\" \" -locale:LOCALE : 设置渲染用的 locale 如： -locale:zh_CN.UTF-8 将使用简体中文 locale (',' 逗号是数值分隔符)\" \" in=pos: 渲染起始帧号\" \" out=pos: 渲染终止帧号\" \" render: melt渲染器可执行程序的位置\" \" profile: MLT 视频预设格式\" \" rendermodule: 用于渲染的 MLT consumer，通常为 ffmpeg avformat 编码器\" \" player: 播放器应用的可执行程序位置, 使用参数 '-' 来禁用渲染完成后自动使用播放器播放\" \" src: 输入文件 (通常为 MLT XML 或编辑软件项目文件)\" \" dest: 输出文件\" \" args: 由空格分割开的 libavformat 参数\" ├─src 构建主要target: 编辑器、kdenliveLib所用的源代码文件夹 │ ├─testingArea 连接kdenliveLib，使用项目资源进行测试的程序代码区 │ ├─tests kdenlive原测试样例代码区，包含了测试数据模型、小组件函数(utils)、添加效果(effect)等测试程序源码 │ └─thumbnailer 依赖于kde框架的生成获取缩略图用的组件，编译生成mltpreview.dll Copyright © Aron.Li 2019 all right reserved，powered by Gitbook该文件修订时间： 2021-06-14 19:45:34 "},"SoftwareFramework.html":{"url":"SoftwareFramework.html","title":"软件架构","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 软件架构 概述 MLT 等依赖 MVC模式 时间线模块结构 (timeline2) GUI元素及用途 使用 Doxygen 生成文档 软件架构 本文档自顶向下地描述了SmartIP-Editor软件的架构 自顶向下的架构描述 MLT 等依赖 MVC 模式 GUI元素与其用途 使用 Doxygen 生成文档 概述 MLT 等依赖 SmartIP-Editor使用了许多第三方库，其中最重要的组件是作为承担视频编辑功能核心的MLT库。其中的melt渲染器进程将剪辑素材和剪辑上应用的效果组织至轨道和时间线，并将数据传入剪辑软件中在视频区域内将内容展示渲染。 软件使用像frei0r、ladspa、movit这样的第三方库来提供各种效果，主要包括两种大类:用于对单个剪辑素材添加效果，如位移、调色等用于设定对两个轨道或剪辑素材进行混合以及混合模式，如叠加、相减、求最大值、溶解等。 在MLT的官方文档Plugins (Services)项下可以查阅这些组件的详细信息MLT Documentation ┌──────────────┐ │SmartIP-Editor├─────┐ └──────────┬───┘ │ 渲染项目 │ │ 参数配置 解码音/视频 │ │ 设置素材的效果 │ │ ┌────┴───┐ │ │ MLT ├─────┤ └────────┘ │ 音/视频效果来源集合 ├───────┬──────┬─────────┐ ┌──┴───┐┌──┴───┐┌─┴─┐┌──────┴──────┐ │frei0r││LADSPA││SoX││libsamplerate│ └──────┘└──────┘└───┘└─────────────┘ MVC模式 本项目中大量使用了MVC架构模型来编写组件，一个典型的例子如下 时间线模块结构 (timeline2) ├─Model ... │ │ 时间线功能函数 │ │ 时间线单个项目数据模型 │ │ 时间线数据模型 │ ...... └─view ... │ 时间线控制器 (Controller) │ ...... ├─qml │ 时间线视图 (View) │ ...... 大致协作图： 此类模块主要的复杂性在于model的种类较多，且存在嵌套关系，需要分析视图层级并找到与其对应的数据模型才能直观地对代码与功能进行对应 GUI元素及用途 这里提到的GUI元素主要指在项目中出现的各类可操作的控制器、展示用的装饰、进行直观数据交互的部件(如视频播放器)等，本部分主要使用图片注解的方式标注Kdenlive和SmartIP-Editor重要界面中出现的各个GUI元素 使用 Doxygen 生成文档 预生成的初版文档页面 主要内容位于类和文件tag下 本项目使用Doxygen自动生成bootstrap风格的文档html，相关操作封装如下，具体请查询Doxygen官方文档 # 适用的doxygen版本为 小于 '1.8.12' # 如果没安装 doxygen 或处于windows环境下，请使用docker ## 拉取最新的doxygen镜像 docker pull hrektts/doxygen ## 在项目目录内执行此命令，输出目录为项目目录下的./html/ ./latex/ 文件夹 docker run -it --rm -v \"$(pwd):/data\" hrektts/doxygen:latest doxygen Doxyfile ## 若无法执行，可以进入容器更换doxygen版本，也可以使用wsl虚拟机安装doxygen，进入项目目录后执行 ### doxygen Doxyfile Doxyfile 中常用的修改参数如下 # 版本号 PROJECT_NUMBER = # 项目名 PROJECT_NAME = \"SmartIP-Editor\" # 解压全部类方法、继承关系 EXTRACT_ALL = YES # 使用UML类图外观 UML_LOOK = YES # 递归遍历路径搜索源码 RECURSIVE = YES # 输入源码根路径 INPUT = src Copyright © Aron.Li 2019 all right reserved，powered by Gitbook该文件修订时间： 2021-06-14 19:36:51 "},"MltDocument.html":{"url":"MltDocument.html","title":"MLT","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 MLT 基本概述 基础设计信息 结构与流程 使用说明 Hello World 工厂 Service的属性 播放列表 滤镜 为Service附加滤镜 混合剪辑 多轨道与过渡 MLT ​ MLT是为电视广播设计的开源多媒体框架。严格来说，它为使项目包含新的音视频源、 滤镜、场景过渡和播放设备提供了可插拔式的架构。 本框架为使用了MLT的服务或应用程序提供了结构体系与实用功能。 就框架本身而言，它只提供了为管理资源，如内存，属性，动态对象加载和实例化服务的抽象类和实用功能程序。 本文档大致分为三部分。第一部分提供对MLT的基础描述，第二部分展示了它如何被使用，最后一部分则结合了扩展系统的强调提示展示了框架的结构与设计。 基本概述 基础设计信息 ​ MLT使用C语言编写，框架除了C99标准与pthread库外没有别的依赖。它遵循基本的面向对象设计范式，许多设计宽松地基于生产者/消费者设计模式。 框架被设计为不影响色彩空间——然而当前实现的模块非常趋向于8bit YUV422格式，但是理论上，这些模块可以被完全替换掉，一些关于这些术语的粗略解读将贯穿于这篇文档的剩余部分。 结构与流程 ​ 一个MLT ‘网络’ 的总体结构可描述为一个‘生产者’与一个‘消费者’之间的连接: ​ 消费者从生产者处请求MLT帧对象，随后对其进行一些操作，并在完成一帧后将其关闭。 一个常见的对此处使用到的”生产者/消费者“术语的混淆是，消费者也许会’生产‘某些东西。举个例子，libdv消费者生产DV并且libdv生产者似乎会去消耗DV。然而，此处的命名约定仅表示MLT 帧对象的生产者与消费者。 换言之——一个生产者生产MLT帧对象，并且一个消费者将消耗MLT帧对象。 一个MLT帧本质上提供一张未压缩的，且与音频样本相关联的图片。 滤镜(Filter) 也可以被放置于生产者与消费者之间： ​ 一个'服务'是一组生产者、滤镜、消费者的集合名称。 连接起来的生产者与消费者或服务之间的交流将执行三个阶段： 获取帧 获取图像 获取音频 MLT采用‘懒加载’——图像与音频不需要从源中解压，直到获取图片与音频数据的函数被调用。 实质上，消费者从其所连接的模块中获取资源——这意味着线程通常属于一个消费者需要实现的领域，并且在消费者类上提供一些基本方法以确保实时吞吐量。 使用说明 Hello World 在我们进入框架架构细节之前，下面提供了一个有效的使用例。 以下部分简单的提供了一个媒体播放器： #include #include #include int main( int argc, char *argv[] ) { // Initialise the factory if ( mlt_factory_init( NULL ) == 0 ) { // Create the default consumer mlt_consumer hello = mlt_factory_consumer( NULL, NULL ); // Create via the default producer mlt_producer world = mlt_factory_producer( NULL, argv[ 1 ] ); // Connect the producer to the consumer mlt_consumer_connect( hello, mlt_producer_service( world ) ); // Start the consumer mlt_consumer_start( hello ); // Wait for the consumer to terminate while( !mlt_consumer_is_stopped( hello ) ) sleep( 1 ); // Close the consumer mlt_consumer_close( hello ); // Close the producer mlt_producer_close( world ); // Close the factory mlt_factory_close( ); } else { // Report an error during initialisation fprintf( stderr, \"Unable to locate factory modules\\n\" ); } // End of program return 0; } 这是一个简单的例子——它不提供任何查找功能或运行时配置设定。 任何MLT应用程序的第一步都是工厂的初始化——这保证了环境配置与MLT能够正常运行。下面是对工厂的细节介绍。 如上例的mlt_factory_consumer与mlt_factory_producer调用，所有的服务都通过工厂实例化。对于滤镜和过渡效果也有类似的工厂。在services.txt中包括了标准服务的详细信息。 此处要求的默认值是一个特殊情况——NULL使用请求代表使用默认的生产者与消费者。 默认生产者是“加载器(loader)”。此生产者通过匹配文件名来定位要使用的服务，并且附加‘标准化滤镜’(如缩放、去交错、重采样和字段标准化器) 到加载的内容当中——这些滤镜保证了消费者得到它所寻求的结果。(Frame?) 默认的消费者是“sdl”。加载器与sdl的组合将提供一个媒体播放器。 在这个例子当中，我们连接生产者并随后启动消费者。我们接下来等待直到消费者运行停止 (此例子中指关闭SDL_Window这一动作) 并在应用程序退出前最终关闭消费者、生产者与工厂。 注意，消费者是线程化(异步?)的——在启动消费者之后以及停止或关闭消费者之前，总是需要等待一些种类的事件。 另外也请注意。你可以重载默认值如下： MLT_CONSUMER=xml ./hello file.avi 这将在标准输出上创建一个xml文档 MLT_CONSUMER=xml MLT_PRODUCER=avformat ./hello file.avi 这将会直接使用avformat生产者播放视频，因此他将避开标准化方法。 MLT_CONSUMER=libdv ./hello file.avi > /dev/dv1394 如果您足够幸运，可以随手将file.avi实时转换为DV格式，并将其广播到您的DV设备中。 工厂 正如'Hello World'例子中所展示的那样，工厂可以创建服务对象。 框架本身不提供服务——服务以插件的形式被提供。插件以\"模块\"的形式组织，并且一个模块可以提供许多不同种类的服务。 一旦工厂被初始化，所有配置好的服务就都可以被使用。 mlt_factory_prefix()返回安装各模块的目录路径，这可以被明确表示在mlt_factory_init调用其本身种，或它可以通过环境变量MLT_REPOSITORY明确表示，亦或者在这两者都缺乏配置的情况下，它将默认返回安装了prefix/shared/mlt/modules的路径。 mlt_environment()提供与如下表格中所示的名称=值集合的只读连接： | 名称 | 描述 | 值 | | ----------------- | ---------------- | -------------- | | MLT_NORMALISATION | 系统的标准化 | PAL或NTSC | | MLT_PRODUCER | 默认生产者 | “loader”或其他 | | MLT_CONSUMER | 默认消费者 | \"sdl\"或其他 | | MLT_TEST_CARD | 默认检测卡生产者 | 任何生产者 | 这些值将从同名的环境变量中初始化。 如上方所展示的，一个生产者可以用\"默认标准化\"生产者来创建，并且他们也可以被使用名字来请求。滤镜和过渡总是被用名字来请求——此处没有它们的'默认'概念。 Service的属性 所有的服务都拥有它们能够用来操纵影响它们行为的属性集合。 为了在服务上设置属性，我们需要检索与他相联系的属性。对生产者来说，这是被调用以下方法完成的： mlt_properties properties = mlt_producer_properties(producer); 所有的服务都有一个相似的关系方法。 一旦完成了数据检索，设置与获取属性就能够直接在这个对象上操作完成，举个例子： mlt_properties_set(properties, \"name\", \"value\"); 更多关于属性对象的完备的描述可以在下方找到。 播放列表 到目前为止，我们已经展示了一个简单的生产者/消费者配置——下一阶段是要将生产者组织到播放列表当中。 假设我们正在改写\"Hello World\"样例，并且希望添加一系列文件到播放队列，即： hello*.avi 我们将创建一个新的名为create_playlist的函数而不是直接调用mlt_factory_producer。此函数负责创建播放列表，创建每一个生产者并将它们添加到播放列表当中。 mlt_producer create_playlist( int argc, char **argv ) { // We're creating a playlist here mlt_playlist playlist = mlt_playlist_init( ); // We need the playlist properties to ensure clean up mlt_properties properties = mlt_playlist_properties( playlist ); // Loop through each of the arguments int i = 0; for ( i = 1; i 注意到我们在添加生产者到播放列表后就关闭了它们，实际上，我们所做的是关闭我们对此生产者的引用——播放列表创建了属于播放列表自身的对生产者的引用并将其插入，并且当播放列表被销毁时，它会关闭自身对生产者的引用。 还要注意，如果添加同一生产者的多个实例到播放列表，它将创建对其的多个引用。 现在我们所要做的是替换主函数中的这一行： // Create a normalised producer mlt_producer world = mlt_factory_prodi 为 // Create a normalised producer mlt_producer world = create_playlist(argc, argv); 然后我们便有方法去播放复数片段。 [*] 此处的引用设计在MLT 0.1.2中有介绍——它100%适用于早期的注册引用与销毁播放列表对象的属性。 滤镜 在生产者和消费者之间插入滤镜只是对其的一种实例化，第一步滤镜连接到生产者，再将滤镜连接到消费者。 举个例子： // Create a producer from something mlt_producer producer = mlt_factory_producer( ... ); // Create a consumer from something mlt_consumer consumer = mlt_factory_consumer( ... ); // Create a greyscale filter mlt_filter filter = mlt_factory_filter( \"greyscale\", NULL ); // Connect the filter to the producer mlt_filter_connect( filter, mlt_producer_service( producer ), 0 ); // Connect the consumer to filter mlt_consumer_connect( consumer, mlt_filter_service( filter ) ); 与生产者和消费者一样，滤镜也能被通过修改它的属性对象操作——mlt_filter_properties方法能够被调用并且属性可以按要求进行设定。 滤镜连接函数中的附加参数很重要，因为它规定了滤镜运作的'轨迹'。对基础的生产者与播放列表，它们只有一个轨迹(0)，正如您将在下一节看到的，即使有多个轨迹也只有单一的能够产生输出。 为Service附加滤镜 所有的服务都可以拥有附加滤镜。 考虑下面的例子： // Create a producer mlt_producer producer = mlt_factory_producer( NULL, clip ); // Get the service object of the producer mlt_producer service = mlt_producer_service( producer ); // Create a filter mlt_filter filter = mlt_factory_filter( \"greyscale\" ); // Create a playlist mlt_playlist playlist = mlt_playlist_init( ); // Attach the filter to the producer mlt_service_attach( producer, filter ); // Construct a playlist with various cuts from the producer mlt_playlist_append_io( producer, 0, 99 ); mlt_playlist_append_io( producer, 450, 499 ); mlt_playlist_append_io( producer, 200, 399 ); // We can close the producer and filter now mlt_producer_close( producer ); mlt_filter_close( filter ); 当播放结束时，灰度缩放滤镜将会对播放列表中来自特点生产者的每一帧执行处理。 此外，每个剪辑都可以拥有它们自身的附加滤镜，这些滤镜将在生产者的滤镜后执行。举个例子： // Create a new filter filter = mlt_factory_filter( \"invert\", NULL ); // Get the second 'clip' in the playlist producer = mlt_playlist_get_clip( 1 ); // Get the service object of the clip service = mlt_producer_service( producer ); // Attach the filter mlt_service_attach( producer, filter ); // Close the filter mlt_filter_close( filter ); 甚至播放列表本身也可以附加滤镜 // Create a new filter filter = mlt_factory_filter( \"watermark\", \"+Hello.txt\" ); // Get the service object of the playlist service = mlt_playlist_service( playlist ); // Attach the filter mlt_service_attach( service, filter ); // Close the filter mlt_filter_close( filter ); 当然，播放列表作为生产者，可以被切分并放置在另一个播放列表上，并且滤镜可以被添加到这些切分或新的播放列表本身上。 附加滤镜的主要优势是它们能够保持连接并且不会遭受插入项目 和计算替换出入点等维护问题的影响——如果您在多轨道领域内大量使用插入分离式的滤镜，这将会成为一个主要问题。 混合剪辑 混合是最简单的介绍播放列表中相邻的两个剪辑间过渡的方式考虑存在下面的播放列表： 让我们假设'X'是由50帧长度的黑幕组成 当播放时，将会获得50帧黑幕，然后开始播放A，紧接着切换到播放B，最终又播放黑幕'X' 我们那的目的是将播放列表转换为像这样的模式： 当一块剪辑中指向两个剪辑时会展示一个过渡，注意这个播放列表会较上一个短一些，这也是我们所期望的：再两个剪辑中添加一个简单的50帧过渡来代替直接播放50帧黑幕。 这一工作使用mlt_playlist_mix方法来完成，因此，假设你有一个像原图中那样的播放列表，在做第一个混合片段时，你可以这样做： // 创建一个过渡 mlt_transition transition = mlt_factor_transition( \"luma\", NULL ); // 将第一个和第二个剪辑混合50帧长度 mlt_playlist_mix( playlist, 0, 50, transition ); // 关闭过渡 mlt_transition_close( transition ); 这将会提供给你第一个过渡（转场）注意这将会在播放列表中创建一个新的剪辑。 作为一般提示，为了获取下一个剪辑索引的这一需求，你需要仿照以下的例子： // 获得播放列表中的剪辑数量 int i = mlt_playlist_count( ); // 通过逆序迭代它们 while ( i -- ) { // 开启转场 mlt_transition transition = mlt_factor_transition( \"luma\", NULL ); // 混合第1，2个剪辑的各50帧 mlt_playlist_mix( playlist, i, 50, transition ); // 关闭转场 mlt_transition_close( transition ); } 这是另一种像在新创建的剪辑和当前剪辑间使用mlt_playlist_join的方式（你可以通过比较调用mix命令前后播放列表的长度变化来确定新的剪辑是否被创建） 内部的，mlt_playlist_mix调用生成了像下方所描述那样的多轨道。如同附加滤镜，混合操作使插入剪辑到列表中变得非常简单。 同样需要注意：混合使用允许一个简单的用户接口 - 不同于强制使用复杂的多轨道对象，你可以在单个轨道上进行许多操作。因此，额外的轨道可以提供给音频混录、复合等，混合或合成等被独立定位的操作而不会影响到其他轨道。 多轨道与过渡 MLT框架处理多轨道时需要受到两个约束： 消费者和生产者需要通过一个框架相互通信 能够序列化和操作一个‘网络’(或者说滤镜图) 我们可以可视化一个多轨道模型如下： 轨道0和轨道1的重合区域可能会又某种转场 - 没有转场时，从b1到a2中的帧将在重叠区域中显示（由高到低图层叠加顺序） MLT有一个多轨道对象，但它并不是生产者，因为它可以直接连接到使用者，并且消费者会像对待普通生产者一样对待它。在上图的多轨道模型种，除了剪辑之间的过渡外，从轨道1种看不到任何a1-a2相关的东西 消费者从与其连接的生产者处拉出一帧，而多轨道模型种的每个轨道提供一帧，必须在某处确保能够拉出每一条轨道中的帧，并选择正确的方式进行传递。 因此，MLT为多轨道模型提供了封装（称为‘tractor’轨道头、牵引头）牵引头会保证输出正确的帧以及保证所具有的类似生产者行为。 有了牵引头和多轨道模型的连接，现在我们可以将多轨道连接到消费者。 轨道可以是生产者，播放列表，甚至其他的牵引头。 现在我们希望在牵引头和多轨道模型种插入滤镜和转场，我们可以直接使用插入滤镜在二者中间完成这一工作，但是这涉及到左右生产者和消费者的连接和重连，似乎只有我们令这一进程自动化后才显得很恰当。 新的概念‘field’场地诞生了，我们在场地种‘种植’滤镜和转场，牵引头拉动多轨道模型经过场地并生产出一帧。 这样，我们需要先创建牵引头，然后跟上我们获得的多轨道模型和场地对象。我们能够为他们输入数据并最终将牵引头连接到一个消费者 本质上来说，它在消费者看起来是这样的： 一个例子将帮助我们如愿以偿地弄清楚它。 让我们假设要提供‘水印’到我们的‘hello world’例子当中，我们已经扩展了例子到能够播放多个剪辑，现在我们将放置一个基于文本的水印，于左上角写着‘Hello World’： mlt_producer create_tracks( int argc, char **argv ) { // 创建牵引头 mlt_tractor tractor = mlt_tractor_new( ); // 创建场地对象 mlt_field field = mlt_tractor_field( tractor ); // 创建多轨道对象 mlt_multitrack multitrack = mlt_tractor_multitrack( tractor ); // 创建一个复合转场 mlt_transition transition = mlt_factory_transition( \"composite\", \"10%/10%:15%x15%\" ); // 创建轨道0 mlt_producer track0 = create_playlist( argc, argv ); // 创建水印轨道1 mlt_producer track1 = mlt_factory_producer( \"loader\", \"pango\" ); // 获得轨道0的长度 mlt_position length = mlt_producer_get_playtime( track0 ); // 设置轨道1的属性 mlt_properties properties = mlt_producer_properties( track1 ); mlt_properties_set( properties, \"text\", \"Hello\\nWorld\" ); mlt_properties_set_position( properties, \"in\", 0 ); mlt_properties_set_position( properties, \"out\", length - 1 ); mlt_properties_set_position( properties, \"length\", length ); mlt_properties_set_int( properties, \"a_track\", 0 ); mlt_properties_set_int( properties, \"b_track\", 1 ); // 现在设置转场的属性 properties = mlt_transition_properties( transition ); mlt_properties_set_position( properties, \"in\", 0 ); mlt_properties_set_position( properties, \"out\", length - 1 ); // 添加我们的轨道到多轨道模型种 mlt_multitrack_connect( multitrack, track0, 0 ); mlt_multitrack_connect( multitrack, track1, 1 ); // 种植滤镜到场地 mlt_field_plant_transition( field, transition, 0, 1 ); // 关闭引用 mlt_producer_close( track0 ); mlt_producer_close( track1 ); mlt_transition_close( transition ); // 返回牵引头 return mlt_tractor_producer( tractor ); } 现在我们所要做的就是替换主函数中的这些行 // 创建播放列表 mlt_producer world = create_playlist(argc, argv); 用以下内容替换： // 创建带水印的播放列表 mlt_producer world = create_tracks(argc, argv); 顺便一提，在生产者与消费者之间插入更简单的水印滤镜也可以实现相同的目的。 Copyright © Aron.Li 2019 all right reserved，powered by Gitbook该文件修订时间： 2021-06-23 12:05:41 "},"ImportantClasses.html":{"url":"ImportantClasses.html","title":"重要类说明","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 重要类说明 MainWindow 重要类说明 MainWindow Copyright © Aron.Li 2019 all right reserved，powered by Gitbook该文件修订时间： 2021-06-16 21:01:45 "},"EffectClasses.html":{"url":"EffectClasses.html","title":"Effect类族","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 Effect类族 EffectStackModel Effect类族 ​ 本项目中使用到的效果(Mlt::Filter/Mix/Transition)通过每个剪辑素材生成的对象ProjectClip中的EffectStackModel来管理 EffectStackModel ​ EffectStackModel继承自树状模型TreeModel Copyright © Aron.Li 2019 all right reserved，powered by Gitbook该文件修订时间： 2021-06-23 14:14:24 "},"EffectsDocument.html":{"url":"EffectsDocument.html","title":"常用效果文档","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 常用效果文档 一、位置与尺寸 1.1、affine (cpu) 1.2、movit.rect (gpu) 二、绿屏抠图 1.1、frei0r.select0r (cpu) 常用效果文档 本文档为项目中所使用的剪辑素材编辑效果以及其对应的Mlt::Filter相关参数说明 [] 表示参数可选 参考文档MLT Documentation](https://www.mltframework.org/docs/)) 注意：形如producer.xxx transition.xxx的属性对应键名称并不是\"xxx\"，而是\"producer.xxx transition.xxx\" 一、位置与尺寸 1.1、affine (cpu) 键名 类型 特殊属性 备注 background string 通过创建Mlt::Producer来充当背景图片，一般以颜色为主(colour:0xrrggbbaa producer.* Mlt::Properties 对应Mlt::Producer的属性键值对 use_normalised bool 当此属性值为true时，Mlt::Consumer在请求帧对象时会使用项目预设分辨率(从Mlt::Profile)而不是素材自身的分辨率 transition.* Mlt::Properties 作为Filter的效果affine和作为转场Transition的效果具有相同的属性，同样，这也是使用此效果需要设置的主要属性 转场(transition.*)属性部分 keyed bool 标注是否启用mlt::animation，默认为false rect rect(格式化string) 支持关键帧 指定了一个矩形的位置和大小，格式为\"X/Y:WxH[:不透明度]\"其中X Y W H 不透明度为主要变参，可以使用确切的数值或百分比，各参数是否使用百分比表示需要保持一致一般使用百分比，例：0%/0%:100%x100%:100% distort bool 判断是否无视视频素材的宽高比来填充显示整个区域 rotate族 如果keyed设置为false，则表示将旋转值值应用到每一帧 fix_rotate_x float 支持关键帧 绕坐标系X轴旋转的角度 fix_rotate_y float 支持关键帧 绕坐标系Y轴旋转的角度 fix_rotate_z float 支持关键帧 绕坐标系Z轴旋转的角度 shear族(平行四边形化) fix_shear_x float 支持关键帧 X方向的形变数值 default:0 fix_shear_y float 支持关键帧 Y方向的形变数值 default:0 fix_shear_z float 支持关键帧 Z方向的形变数值 default:0 halign string 设定水平对齐的方式，合法取值如下 left center* right valign string 设定垂直对齐的方式，合法取值如下 left center* right 1.2、movit.rect (gpu) 二、绿屏抠图 1.1、frei0r.select0r (cpu) 色彩空间: Red-Green-Blue=RGB 红色-绿色-蓝色 Hue-Chroma-Intensity=HCI 色相-饱和度-明度 键名 标题 类型 特殊属性 备注 0 色键颜色 color (格式化string) 选定为色键目标的颜色值，格式为#RRGGBB默认值: #00cc00 1 透明区域反转 bool 设置是否反转Filter处理后的透明度结果值 2 红色差值/色相差值 double 范围[0~1] 参数差值分量0 3 绿色差值/饱和度差值 double 范围[0~1] 参数差值分量1 4 蓝色差值/明度差值 double 范围[0~1] 参数差值分量2 5 梯度 double 范围[0~1] 参数变化的梯度大小 6 色彩空间 double 仅使用0、1 确定使用哪种色彩空间0.0：RGB 1.0：HCI 7 形状 double value ∈ [0.0, 0.5, 1.0] 0.0：矩形0.5：椭圆形1.0：菱形 8 边缘类型 double value ∈ [0.0, 0.35, 0.6, 0.7, 0.9] 0.0：硬边0.35：厚边0.6：正常0.7：薄边0.8：梯度 9 操作类型 double value ∈ [0.0, 0.3, 0.5, 0.7, 1.0] 0.0：覆盖0.3：最大值0.5：最小值0.7：相加1.0：相减 Copyright © Aron.Li 2019 all right reserved，powered by Gitbook该文件修订时间： 2021-06-23 18:46:46 "},"UsefulOperations.html":{"url":"UsefulOperations.html","title":"其他常用操作","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 其他常用操作 一、环境配置 1.1、配置craft 1.1.1、安装python3.x 1.1.2、安装powershell 5.0以上版本 1.1.3、配置编译器 1.1.4、使用方才安装的powershell运行craft.ps1 1.1.5、安装完成 1.2、编译kdenlive 1.3、配置SmartIP-Editor项目 1.3.1、获取源代码 1.3.2、配置QtCreator 1.4、部署项目 二、添加文件到项目 2.1、传统widget类的 .UI 文件和 C++源文件.h .cpp 2.1.1 添加UI 2.1.2 添加 class 文件 2.1.3、 类代码引用UI 2.2、注意事项 三、打包项目 3.1、简便方法 3.1.1、下载运行环境并解压 3.1.2、复制扩展qml文件 3.1.3、添加必要文件 3.1.4、编译项目 生成可执行文件 3.1.5、压缩包打包(当前) 3.1.6、提示 其他常用操作 一、环境配置 1.1、配置craft 1.1.1、安装python3.x 下载python3.x版本，安装后配置好环境变量，确保python命令能够执行 1.1.2、安装powershell 5.0以上版本 下载powershell 7运行PowerShell-7.1.3-win-x64.msi 安装流程安装完毕后默认情况下，包安装位置为 盘符:ProgramFiles\\PowerShell\\ 如果安装时没勾选添加安装路径添加到${PATH}内，则进行添加 使用管理员权限运行powershell，键入以下命令以启用脚本运行 Set-ExecutionPolicy -Scope CurrentUser RemoteSigned 运行iex ((new-object net.webclient).DownloadString('https://raw.githubusercontent.com/KDE/craft/master/setup/install_craft.ps1')) 1.1.3、配置编译器 下载MinGW64 8.1.0版本(一些版本的Qt自带，可以在Qt安装目录\\Tools\\mingw810_64\\目录下找到) 添加Qt安装目录\\Tools\\mingw810_64\\bin至环境变量 1.1.4、使用方才安装的powershell运行craft.ps1 此步骤中的错误大多为网络问题，注意fetch/get failed等词标志此错误 选择craft的安装目录 选择默认编译器为MinGW(输入0) 随喜好选择，如果选择yes则需要额外下载一些组件 等待下载，安装完成，如果由于网络问题导致软件包下载失败，重新运行craft.ps1重复安装流程，此前可以将download包剪切到目录外，删除安装目录(如: C:\\CraftRoot) 选择完安装目录后，将download文件夹重新粘贴进安装目录，可以节省下载时间 1.1.5、安装完成 安装完成后，运行Craft安装目录\\craft\\craftenv.ps1，出现类似以下信息则说明craft配置完成 Craft : A:\\CraftRootVersion : masterABI : windows-mingw_64-gccDownload directory : A:\\CraftRoot\\download 编辑环境变量: PATH=$(PATH);C:\\CraftRoot\\bin;C:\\CraftRoot\\dev-utils\\bin\\;C:\\CraftRoot\\mingw64\\bin 编辑变量 CMAKE_PREFIX_PATH, 添加Craft安装目录 (如: CMAKE_PREFIX_PATH:STRING=%{Qt:QT_INSTALL_PREFIX};C:\\CraftRoot) 1.2、编译kdenlive 命令行中输入craft kdenlive (默认构建模式为DebWithRelInfo，如果想以debug模式构建，则输入craft --buildtype Debug kdenlive) 如果出现由于zlib库导致的编译失败，运行craft zlib待安装完成后重试 1.3、配置SmartIP-Editor项目 1.3.1、获取源代码 运行powershell，cd到该目录下: craft安装目录\\build\\kde\\kdemultimedia\\kdenlive\\work\\ git clone https://github.com/LCBHSStudent/kdenlive kde_based_editor 1.3.2、配置QtCreator 点击QtCreator菜单栏工具->选项打开选项窗口 选择Kits栏目，打开Qt Versions选项卡，点击添加，选择Craft安装目录\\bin\\qmake.exe 打开编译器选项卡，点击添加，分别添加一个C/C++编译器如下，注意ABI的选择路径为Craft安装目录\\mingw64\\bin\\gcc(g++).exe 添加新的调试器 添加新的CMake 最后，添加Qt Kit，选择CMake、c\\c++编译器、调试器、Qt版本为刚才手动添加的版本 打开项目文件夹根目录下的CMakeLists.txt，选择编译模式为ReleaseWithDebugInformation 选择build target为all和install，编译 1.4、部署项目 编辑python脚本如下 import shutil shutil.copy(r'.\\bin\\SmartIP-Editor.exe', r'A:\\CraftRoot\\bin') # 改为你的craft安装目录 修改项目运行设置，添加部署方法运行刚刚的python脚本 添加项目运行配置 修改后的编译运行小窗： 二、添加文件到项目 2.1、传统widget类的 .UI 文件和 C++源文件.h .cpp ​ 本项目中使用到的.ui设计师文件皆位于src/ui文件夹内，添加传统widget类时最好分开进行添加，先添加.ui文件，再添加类文件.cpp .h 2.1.1 添加UI ​ cmake项目文件中定义了ui的加载位置和使用moc生成xxx_ui.h的函数 81 ## UI's 82 file(GLOB kdenlive_UIS \"ui/*.ui\") 83 ki18n_wrap_ui(kdenlive_UIS ${kdenlive_UIS}) 现在需要将ui文件添加到src/ui文件夹内 选择Qt Designer Form 按照引导后，确定添加 2.1.2 添加 class 文件 ​ 右键文件夹，选择Add new - c++ class创建.cpp 和 .h 文件，添加到项目和添加到版本控制系统都选择none ​ 随后，找到添加的文件夹位置上层的第一个CMakeLists.txt文件，比如此处向widget文件夹中添加了新的文件，则编辑widget文件夹下的CMakeLists.txt set(kdenlive_SRCS ${kdenlive_SRCS} xxx/xxx.cpp xxx/xxx.cpp ... # 这里另起一行，写你新加入的文件相对路径 PARENT_SCOPE) 2.1.3、 类代码引用UI // 包含加入的ui生成的头文件，格式为ui_文件名.h #include \"ui_xxxxxx.h\" 随后，采用继承或成员的方式组合到类中即可 2.2、注意事项 ​ 如果遇到编译失败问题，报出元对象相关错误，请选择构建-重新构建整个项目选项 三、打包项目 3.1、简便方法 3.1.1、下载运行环境并解压 ​ 下载kdenlive官方提供的standalone压缩包，在没有大环境改动的情况下，此安装包几乎包含了程序运行所需要的运行环境 ​ 点此下载，完成后随意解压到某个目录保存使用，记得删除bin/kdenlive.exe 3.1.2、复制扩展qml文件 ​ 下载后，将 CraftRoot/qml下的文件夹DFW与Shotcut复制到解压目录中的bin文件夹内 3.1.3、添加必要文件 ​ 进入bin/data/color-schemes文件夹，添加一个文件名为Classic.colors的文件，内容如下: [ColorEffects:Disabled] Color=56,56,56 ColorAmount=0 ColorEffect=0 ContrastAmount=0.65 ContrastEffect=1 IntensityAmount=0.1 IntensityEffect=2 [ColorEffects:Inactive] ChangeSelectionColor=true Color=112,111,110 ColorAmount=0.025 ColorEffect=2 ContrastAmount=0.1 ContrastEffect=2 Enable=false IntensityAmount=0 IntensityEffect=0 [Colors:Button] BackgroundAlternate=30,87,116 BackgroundNormal=49,54,59 DecorationFocus=62,61,76 DecorationHover=62,61,76 ForegroundActive=62,61,76 ForegroundInactive=161,169,177 ForegroundLink=29,153,243 ForegroundNegative=218,68,83 ForegroundNeutral=246,116,0 ForegroundNormal=252,252,252 ForegroundPositive=39,174,96 ForegroundVisited=155,89,182 [Colors:Complementary] BackgroundAlternate=30,87,116 BackgroundNormal=45,44,57 DecorationFocus=62,61,76 DecorationHover=62,61,76 ForegroundActive=62,61,76 ForegroundInactive=161,169,177 ForegroundLink=29,153,243 ForegroundNegative=218,68,83 ForegroundNeutral=246,116,0 ForegroundNormal=252,252,252 ForegroundPositive=39,174,96 ForegroundVisited=155,89,182 [Colors:Header] BackgroundAlternate=45,44,57 BackgroundNormal=49,54,59 DecorationFocus=62,61,76 DecorationHover=62,61,76 ForegroundActive=62,61,76 ForegroundInactive=161,169,177 ForegroundLink=29,153,243 ForegroundNegative=218,68,83 ForegroundNeutral=246,116,0 ForegroundNormal=252,252,252 ForegroundPositive=39,174,96 ForegroundVisited=155,89,182 [Colors:Header][Inactive] BackgroundAlternate=49,54,59 BackgroundNormal=45,44,57 DecorationFocus=62,61,76 DecorationHover=62,61,76 ForegroundActive=62,61,76 ForegroundInactive=161,169,177 ForegroundLink=29,153,243 ForegroundNegative=218,68,83 ForegroundNeutral=246,116,0 ForegroundNormal=252,252,252 ForegroundPositive=39,174,96 ForegroundVisited=155,89,182 [Colors:Selection] BackgroundAlternate=30,87,116 BackgroundNormal=62,61,76 DecorationFocus=62,61,76 DecorationHover=62,61,76 ForegroundActive=252,252,252 ForegroundInactive=161,169,177 ForegroundLink=253,188,75 ForegroundNegative=218,68,83 ForegroundNeutral=246,116,0 ForegroundNormal=252,252,252 ForegroundPositive=39,174,96 ForegroundVisited=155,89,182 [Colors:Tooltip] BackgroundAlternate=45,44,57 BackgroundNormal=49,54,59 DecorationFocus=62,61,76 DecorationHover=62,61,76 ForegroundActive=62,61,76 ForegroundInactive=161,169,177 ForegroundLink=29,153,243 ForegroundNegative=218,68,83 ForegroundNeutral=246,116,0 ForegroundNormal=252,252,252 ForegroundPositive=39,174,96 ForegroundVisited=155,89,182 [Colors:View] BackgroundAlternate=35,38,41 BackgroundNormal=27,30,32 DecorationFocus=62,61,76 DecorationHover=62,61,76 ForegroundActive=62,61,76 ForegroundInactive=161,169,177 ForegroundLink=29,153,243 ForegroundNegative=218,68,83 ForegroundNeutral=246,116,0 ForegroundNormal=252,252,252 ForegroundPositive=39,174,96 ForegroundVisited=155,89,182 [Colors:Window] BackgroundAlternate=49,54,59 BackgroundNormal=45,44,57 DecorationFocus=62,61,76 DecorationHover=62,61,76 ForegroundActive=62,61,76 ForegroundInactive=161,169,177 ForegroundLink=29,153,243 ForegroundNegative=218,68,83 ForegroundNeutral=246,116,0 ForegroundNormal=252,252,252 ForegroundPositive=39,174,96 ForegroundVisited=155,89,182 [General] ColorScheme=Classic Name=Classic Name[zh_CN]=经典 Name[zh_TW]=經典 shadeSortColumn=true [KDE] contrast=4 [WM] activeBackground=49,54,59 activeBlend=252,252,252 activeForeground=252,252,252 inactiveBackground=45,44,57 inactiveBlend=161,169,177 inactiveForeground=161,169,177 3.1.4、编译项目 生成可执行文件 ​ 使用cmake的MinisizeRelease模式编译生成SmartIP-Editor.exe，完成后放入解压缩运行环境中的bin文件夹即可 3.1.5、压缩包打包(当前) ​ 使用WinRAR等压缩软件将整个解压目录压缩至一个压缩文件内，同样，解压此压缩包后双击bin中的SmartIP-Editor.exe即可运行程序 3.1.6、提示 ​ 后续更新打包时只需要替换压缩包/解压目录中的exe文件即可，保留功后续使用以省略上面的某些步骤 Copyright © Aron.Li 2019 all right reserved，powered by Gitbook该文件修订时间： 2021-06-29 11:49:00 "}}